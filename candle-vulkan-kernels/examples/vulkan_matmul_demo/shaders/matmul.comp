#version 450

// Simple matrix multiplication compute shader
// Performs: C = A * B
// where A is M×K, B is K×N, C is M×N

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Storage buffers for input matrices and result
layout(set = 0, binding = 0) buffer MatrixA {
    float data[];
} matrix_a;

layout(set = 0, binding = 1) buffer MatrixB {
    float data[];
} matrix_b;

layout(set = 0, binding = 2) buffer MatrixC {
    float data[];
} matrix_c;

// Push constants for matrix dimensions
layout(push_constant) uniform PushConstants {
    uint m;       // rows of A and C
    uint n;       // cols of B and C
    uint k;       // cols of A and rows of B
    uint stride_a;  // stride for matrix A in elements
    uint stride_b;  // stride for matrix B in elements
    uint stride_c;  // stride for matrix C in elements
} push_constants;

shared float tile_a[16][16];
shared float tile_b[16][16];

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;

    // Calculate workgroup position
    uint wg_row = gl_WorkGroupID.y;
    uint wg_col = gl_WorkGroupID.x;

    // Local position within workgroup
    uint local_row = gl_LocalInvocationID.y;
    uint local_col = gl_LocalInvocationID.x;

    // Initialize accumulator
    float sum = 0.0f;

    // Loop over K dimension, processing tiles
    for (uint tile_idx = 0; tile_idx < (push_constants.k + 15) / 16; tile_idx++) {
        // Load tile from A into shared memory
        uint a_col = tile_idx * 16 + local_col;
        if (a_col < push_constants.k && row < push_constants.m) {
            uint idx_a = row * push_constants.stride_a + a_col;
            tile_a[local_row][local_col] = matrix_a.data[idx_a];
        } else {
            tile_a[local_row][local_col] = 0.0f;
        }

        // Load tile from B into shared memory
        uint b_row = tile_idx * 16 + local_row;
        if (b_row < push_constants.k && col < push_constants.n) {
            uint idx_b = b_row * push_constants.stride_b + col;
            tile_b[local_row][local_col] = matrix_b.data[idx_b];
        } else {
            tile_b[local_row][local_col] = 0.0f;
        }

        // Synchronize all threads in workgroup
        barrier();

        // Compute partial results using shared tiles
        for (uint k = 0; k < 16; k++) {
            sum += tile_a[local_row][k] * tile_b[k][local_col];
        }

        // Synchronize before loading next tiles
        barrier();
    }

    // Write final result to global memory
    if (row < push_constants.m && col < push_constants.n) {
        uint idx_c = row * push_constants.stride_c + col;
        matrix_c.data[idx_c] = sum;
    }
}
